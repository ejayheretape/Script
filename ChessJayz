local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

getgenv().__CH_DATA = getgenv().__CH_DATA or {
    engines = {"Stockfish","Lc0","Torch","Dx100","KnightX","HyperX","Br1lliance","Undefeated","WurstEngine"},
    config = {engine="Stockfish", autoPlay=false}
}

local function fetchFEN()
    local ev = RS:FindFirstChild("InternalClientEvents")
    if not ev then warn("fetchFEN: InternalClientEvents not found") return nil end
    local ok, active = pcall(function() return ev.GetActiveTableset:Invoke() end)
    if not ok or not active then warn("fetchFEN: Failed to get active tableset, ok="..tostring(ok)) return nil end
    for i=1,5 do
        local fenobj = active:FindFirstChild("FEN")
        if fenobj then return fenobj.Value end
        task.wait(0.1)
    end
    warn("fetchFEN: FEN object not found after retries")
    return nil
end

local function queryWebEngine(fen, engine)
    local body = {fen=fen}
    local isWurst = engine == "WurstEngine"
    if isWurst then
        body.depth = 18
        body.maxThinkingTime = 100
        body.variants = 5
    end
    local attempts = 5  -- Increased retries for long sessions
    local res
    for i=1,attempts do
        local ok, result = pcall(function()
            return (syn and syn.request or http_request or request)({
                Url = "https://chess-api.com/v1",
                Method = "POST",
                Headers = {["Content-Type"]="application/json"},
                Body = HttpService:JSONEncode(body)
            })
        end)
        if ok and result and result.Body then
            res = result
            break
        end
        warn("queryWebEngine: Attempt "..i.." failed, ok="..tostring(ok)..", result="..tostring(result))
        task.wait(1)  -- Increased delay to respect potential undocumented rate limits
    end
    if not res or not res.Body then warn("queryWebEngine: All attempts failed") return nil end
    local ok2, data = pcall(function() return HttpService:JSONDecode(res.Body) end)
    if not ok2 or not data then warn("queryWebEngine: JSON decode failed, ok2="..tostring(ok2)) return nil end
    local recommendations = data.recommendations or {data}
    if #recommendations == 0 then warn("queryWebEngine: No recommendations") return nil end
    local selected = recommendations[1]
    if isWurst then
        for _, rec in ipairs(recommendations) do
            if rec.isCapture then
                selected = rec
                break
            end
        end
    end
    if selected.from and selected.to then return selected.from, selected.to end
    warn("queryWebEngine: Invalid move data")
    return nil
end

local function computeMove()
    local fen
    local attempts = 10  -- Increased for longer waits between games
    for i=1,attempts do
        fen = fetchFEN()
        if fen then break end
        warn("computeMove: FEN fetch failed, attempt "..i)
        task.wait(0.5)  -- Increased delay to handle game transitions
    end
    if not fen then warn("computeMove: No FEN after retries - possibly no active game") return nil end
    local engine = getgenv().__CH_DATA.config.engine
    return queryWebEngine(fen, engine)
end

local function PlayBestMove()
    local f, t = computeMove()
    if f and RS:FindFirstChild("Chess") then
        local ok, err = pcall(function() RS.Chess.SubmitMove:InvokeServer(f..t) end)
        if not ok then warn("PlayBestMove: SubmitMove failed, error="..tostring(err)) end
    else
        warn("PlayBestMove: Invalid move or Chess service missing, f="..tostring(f))
    end
end

local autoPlayRunning = false
local matchCount = 0
local function startAutoPlay()
    if autoPlayRunning then warn("startAutoPlay: Already running") return end
    autoPlayRunning = true
    matchCount = 0
    spawn(function()
        while getgenv().__CH_DATA.config.autoPlay and autoPlayRunning do
            local success, err = pcall(function()
                PlayBestMove()
                matchCount = matchCount + 1
                print("AutoPlay: Completed move for match #"..matchCount)
            end)
            if not success then
                warn("AutoPlay: Error in move execution, err="..tostring(err))
                if matchCount >= 6 then
                    warn("AutoPlay: Passed 6 matches, continuing to monitor")
                end
            end
            task.wait(2)  -- Increased delay to 2 seconds for sustainability over 1000 matches
        end
        autoPlayRunning = false
        print("AutoPlay: Stopped, final match count="..matchCount)
    end)
end

-- GUI code remains the same as before
local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Parent = player:WaitForChild("PlayerGui")
gui.ResetOnSpawn = false

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 180, 0, 150)
frame.Position = UDim2.new(0.7, 0, 0.2, 0)
frame.BorderSizePixel = 0
frame.Parent = gui

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0,10)
uicorner.Parent = frame

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(120,0,150)), ColorSequenceKeypoint.new(1, Color3.fromRGB(200,100,255))}
gradient.Rotation = 45
gradient.Parent = frame

local dragging, dragInput, dragStart, startPos
local function update(input)
    local delta = input.Position - dragStart
    frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

frame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0,35,0,35)
toggleBtn.Position = UDim2.new(1,5,0,-5)
toggleBtn.Text = "❌"
toggleBtn.BackgroundColor3 = Color3.fromRGB(200,0,0)
toggleBtn.TextColor3 = Color3.new(1,1,1)
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextScaled = true
toggleBtn.Parent = frame

local open = true
toggleBtn.MouseButton1Click:Connect(function()
    open = not open
    frame.Visible = open
    toggleBtn.Text = open and "❌" or "✔️"
end)

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, -20, 0, 18)
label.Position = UDim2.new(0,10,0,10)
label.Text = "Engine"
label.TextColor3 = Color3.new(1,1,1)
label.BackgroundTransparency = 1
label.Font = Enum.Font.GothamBold
label.TextScaled = true
label.Parent = frame

local dropdown = Instance.new("TextButton")
dropdown.Size = UDim2.new(1, -20, 0, 25)
dropdown.Position = UDim2.new(0,10,0,30)
dropdown.TextColor3 = Color3.new(1,1,1)
dropdown.Font = Enum.Font.Gotham
dropdown.TextScaled = true
dropdown.Text = getgenv().__CH_DATA.config.engine
dropdown.Parent = frame

local dropdownGradient = Instance.new("UIGradient")
dropdownGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(150,0,200)), ColorSequenceKeypoint.new(1, Color3.fromRGB(220,150,255))}
dropdownGradient.Rotation = 45
dropdownGradient.Parent = dropdown

local dropdownFrame = Instance.new("Frame")
dropdownFrame.AnchorPoint = Vector2.new(0,1)
dropdownFrame.Position = UDim2.new(0,0,0,0)
dropdownFrame.Size = UDim2.new(1,0,0,0)
dropdownFrame.BackgroundTransparency = 1
dropdownFrame.Parent = dropdown
dropdownFrame.ClipsDescendants = true

local layout = Instance.new("UIListLayout")
layout.Parent = dropdownFrame
layout.SortOrder = Enum.SortOrder.LayoutOrder

for _,eng in ipairs(getgenv().__CH_DATA.engines) do
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1,0,0,20)
    btn.Text = eng
    btn.Font = Enum.Font.Gotham
    btn.TextScaled = true
    btn.TextColor3 = Color3.new(1,1,1)
    btn.BackgroundColor3 = Color3.fromRGB(100,0,150)
    btn.Parent = dropdownFrame

    local btnGradient = Instance.new("UIGradient")
    btnGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(120,0,200)), ColorSequenceKeypoint.new(1, Color3.fromRGB(200,100,255))}
    btnGradient.Rotation = 45
    btnGradient.Parent = btn

    btn.MouseButton1Click:Connect(function()
        getgenv().__CH_DATA.config.engine = eng
        dropdown.Text = eng
        dropdownFrame:TweenSize(UDim2.new(1,0,0,0), "Out", "Quad", 0.2, true)
    end)
end

dropdown.MouseButton1Click:Connect(function()
    local isOpen = dropdownFrame.Size.Y.Offset == 0
    local targetHeight = isOpen and (#getgenv().__CH_DATA.engines*20) or 0
    dropdownFrame:TweenSize(UDim2.new(1,0,0,targetHeight), "Out", "Quad", 0.2, true)
end)

local playBtn = Instance.new("TextButton")
playBtn.Size = UDim2.new(1, -20, 0, 30)
playBtn.Position = UDim2.new(0,10,0,65)
playBtn.Text = "Play Best Move"
playBtn.TextColor3 = Color3.new(1,1,1)
playBtn.Font = Enum.Font.GothamBold
playBtn.TextScaled = true
playBtn.Parent = frame

local playGradient = Instance.new("UIGradient")
playGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(150,0,200)), ColorSequenceKeypoint.new(1, Color3.fromRGB(220,150,255))}
playGradient.Rotation = 45
playGradient.Parent = playBtn

playBtn.MouseButton1Click:Connect(function()
    PlayBestMove()
end)

local autoPlayBtn = Instance.new("TextButton")
autoPlayBtn.Size = UDim2.new(1, -20, 0, 30)
autoPlayBtn.Position = UDim2.new(0,10,0,100)
autoPlayBtn.Text = "Auto Play: OFF"
autoPlayBtn.TextColor3 = Color3.new(1,1,1)
autoPlayBtn.Font = Enum.Font.GothamBold
autoPlayBtn.TextScaled = true
autoPlayBtn.Parent = frame

local autoPlayGradient = Instance.new("UIGradient")
autoPlayGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(150,0,200)), ColorSequenceKeypoint.new(1, Color3.fromRGB(220,150,255))}
autoPlayGradient.Rotation = 45
autoPlayGradient.Parent = autoPlayBtn

autoPlayBtn.MouseButton1Click:Connect(function()
    getgenv().__CH_DATA.config.autoPlay = not getgenv().__CH_DATA.config.autoPlay
    autoPlayBtn.Text = "Auto Play: " .. (getgenv().__CH_DATA.config.autoPlay and "ON" or "OFF")
    autoPlayBtn.BackgroundColor3 = getgenv().__CH_DATA.config.autoPlay and Color3.fromRGB(0,150,0) or Color3.fromRGB(150,0,200)
    if getgenv().__CH_DATA.config.autoPlay then
        startAutoPlay()
    else
        autoPlayRunning = false
        print("AutoPlay: Manually stopped via button")
    end
end)
